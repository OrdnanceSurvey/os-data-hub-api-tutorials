# National Park Locator

Maps help people work out where they are. In this tutorial, we'll build an interactive locator, to help users find features on a map. At Ordnance Survey we love helping people explore the natural beauty of Great Britain, so this project will help users location national parks - but it could just as easily be built to locate stores, offices, railway stations, hospitals and so on. 

## A quick overview

Our locator app will have two main areas of the interface: a list of features to locate in a panel, and a map with those features displayed. 

To make things interesting we are going to connect the two representations of the map geometries - when the user hovers on a national park on the list, the corresponding geometry should highlight, and vice versa. We will also implement event handlers so when a user clicks on either the `<li>` or the polygon, the map zooms to that national park.

## The Data

We created a lightweight JSON file, [`/data/national-parks.json`](./data/national-parks.json). The file contains an GeoJSON FeatureCollection. Each Feature in the collection representsa national park. Each Feature's `property` attribute contains the `name` and a `url` for the park, plus an `id`. 

```json
{
    "type": "FeatureCollection",
    "features": [
        {
            "type": "Feature",
            "properties": {
                "id": 1,
                "name": "Lake District National Park",
                "url": "https://www.lakedistrict.gov.uk/"
            },
            "geometry": {
                "type": "Polygon",
                "coordinates": [
                    [[ -2.671007, 54.47243 ],
                    [ -2.666572, 54.47255 ],
                    [ -2.647861, 54.479841 ],
                    /* ... an array of polygon vertices */
                    ]
                ]
            }
        },
        { /* National Park Feature #2 */ },
         /* ... and so on, for each national park  */
]
```

(As a quick aside - to create this file we fetched national park geometries from the [OS Features API](https://osdatahub.os.uk/docs/wfs/overview)'s Open Zoomstack layer. To simplify the geometries and make this GeoJSON more lightweight, we used [mapshaper.org](https://mapshaper.org/)'s awesome Simplify tool. And we used [`geojson-precision`](https://www.npmjs.com/package/geojson-precision) to trim unnecesary coordinate precision.)

## The HTML

The `index.html` document contains elements ready to accept content dynamically generated by looping through the `national-parks.json` file.

Crucially, the HTML includes a `<ul class="layers">` element, as well as a `<div id="map">`. These two elements are containers for content.

## The JavaScript

In `tutorial.js` the key logic of the locator app is defined. Here we'll walk through line by line to explain how it works. 

### Setting up the map

First, a new Leaflet map object is instantiated and a basemap is added using the OS Maps API. This populates the `#map` div with an OS map.

```javascript

// API key - required to fetch data from the OS Maps API
var apiKey = 'API_KEY_HERE';

// Define map options including where the map loads and zoom constraints
var mapOptions = {
    minZoom: 7,
    maxZoom: 20,
    center: [ 54.92240688263684, -5.84949016571045 ],
    zoom: 7,
    attributionControl: false,
    zoomControl: false
};

// Instantiate a new L.map object
var map = new L.map('map', mapOptions);

// Add scale control to the map.
var ctrlScale = L.control.scale({ position: 'bottomright' }).addTo(map);

// Load and display WMTS tile layer on the map.

var wmtsServiceUrl = 'https://osdatahubapi.os.uk/OSMapsAPI/wmts/v1';

// Define parameters object.
var wmtsParams = {
    key: apiKey,
    service: 'WMTS',
    request: 'GetTile',
    version: '2.0.0',
    height: 256,
    width: 256,
    outputFormat: 'image/png',
    style: 'default',
    layer: 'Outdoor_3857',
    tileMatrixSet: 'EPSG:3857',
    tileMatrix: '{z}',
    tileRow: '{y}',
    tileCol: '{x}'
};

var basemapQueryString = Object.keys(wmtsParams).map(
    function(key) {
            return key + '=' + wmtsParams[key];
        }).join('&');

var basemap = L.tileLayer(
        wmtsServiceUrl + "?" + basemapQueryString, 
        { maxZoom: 20 }
    ).addTo(map);

```

With that our basemap is set up. Next we need to fetch and parse the GeoJSON in `national-parks.json`. We'll add the FeatureCollection as a layer to our map and attach event listeners to each Feature. We'll also loop through the array of Features and add a `<li>` for each national park.

### Event Callbacks

Before we get to the fetch and parse logic though, let's define our event listeners. We'll write functions to highlight and unhighlight both of the visual elements we use to represent each national park: a `<li>` element and a GeoJSON Feature on the map. 

We included the `id` as one of each Feature's properties so we could have a unique reference to each national park. With this id we'll be able to select the right feature from the GeoJSON layer we add to the map, and select the right `<li>` (by a `data-*` attribute) with jQuery. We'll write all of our highlight/unhighlight functions based on this ID.

We also wrote a function - `flyToBoundsOffset()` - to fly to a feature accounting for the lefthand panel that is covering part of the map div. This also 

Looking at the code:

```javascript

// A helper function to select the L.geoJSON Feature layer by its properties.id value. 
function getFeatureById(dataId) {
    
    let filtered = Object.values(map._layers).filter((l) => {
        if ('feature' in l) {
            return l.feature.properties.id == dataId;
        }
    });

    return filtered[0];
}

// Highlights a map feature by ID.
function highlightGeojson( dataId) {

    let geojson = getFeatureById(dataId);
    geojson.setStyle({
        fillOpacity: 0.6,
        weight: 3
    })
}

// Unhighlights a map feature by ID.
function unhighlightGeojson (dataId) {

    let geojson = getFeatureById(dataId);
    geojson.setStyle({
        fillOpacity: 0.3,
        weight: 1
    })
};

// Highlights a li element by data-np-id=ID.
function highlightListElement(dataId) {

    $('[data-np-id="' + String(dataId) + '"]')
        .addClass('highlight');
}

// Unhighlights a li element by data-np-id=ID.
function unhighlightListElement(dataId) {

    $('[data-np-id="' + String(dataId) + '"]')
        .removeClass('highlight')
}

// Animated map.flyToBounds() with padding to account for the panel covering part of the map.
function flyToBoundsOffset(dataId, offsetElSelector, elPosition='left') {

    let offset = $(offsetElSelector).width();

    let geojson = getFeatureById(dataId);

    let paddingOptions;

    if (elPosition == "left") {
        paddingOptions = {
            paddingTopLeft: [offset, 50],
            paddingBottomRight: [50,50]
        }
    } else if (elPosition == "right") {
        paddingOptions = {
            paddingTopLeft: [50, 50],
            paddingBottomRight: [offset,50]
        }
    }

    map.flyToBounds(geojson.getBounds(), paddingOptions)

}

```


### Fetching custom data

Because we're loading data from an external resource, we need to make sure that the data loads before we move on to subsequent lines. We could use a [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for this - but for this tutorial we will write an async function. If you aren't familiar with async/await, take a quick skim of this [MDN article](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await) - it makes writing asynchronous JavaScript clean and easy. 

A note - `await` only works inside `async` functions - not in the top-level scope. For this reason we will place all of our async code inside an [immediately-invoked function expression](https://developer.mozilla.org/en-US/docs/Glossary/IIFE). The pattern looks like `(async function () { /* function body */})()` - note the `()` at the end - the function is "immediately invoked".


```javascript

// A global variable to hold the GeoJSON FeatureCollection. 
var nationalParks;

(async function () {
    nationalParks = await fetch('./data/national-parks.json');
    nationalParks = await nationalParks.json();

// We will not close the function body and invoke it until the end!
```

These two lines fetch the JSON file we prepared, then reads the contents as JSON. The `await` keywords tell the interpreter to wait until that step has completed before moving on to the next. 

### Parks on the map

Now that we've loaded the GeoJSON, let's add it to the map. When we do we will bind event listeners to each feature layer, using Leaflet's `onEachFeature` option. Once we've set up the `L.geoJSON` object, we'll add it to the map.

Note that we'll only work with the map for now - we'll deal with the `<li>` elements later.

```javascript
// ... still inside the async function body!

    // Now that the GeoJSON is loaded and assigned to nationalParks, we create the Leaflet GeoJSON layer 
    let park = L.geoJSON(nationalParks, {
            // The default (i.e. unhighlighted) style for the layer
            style: {
                fillColor: osGreen[3],
                color: osGreen[6],
                fillOpacity: 0.3,
                weight: 1
            },
            // A callback to execute for each Feature in the FeatureCollection
            onEachFeature: function (feature, layer) {
                // Here layer refers to the specific Feature in the collection - each individual national park. We can set multiple event handlers by pass each as an object into the .layer.on() method.
                layer.on({
                    'mouseover': function () {
                        // The functions we defined above!
                        highlightGeojson(feature.properties.id);
                        highlightListElement(feature.properties.id);                                    
                        
                    },
                    'mouseout': function () {
                        // Note how we're passing the id into each function ...
                        unhighlightGeojson(feature.properties.id);
                        unhighlightListElement(feature.properties.id);
                    }, 
                    'click': function () {
                        flyToBoundsOffset(feature.properties.id, '.osel-sliding-side-panel')
                    }
                });
            }
    });

    // And now that the layer is built, add it to the map!
    park.addTo(map);
```

Alright, our geographic features are added to the map with event handlers bound. Now let's set up the lefthand panel with `<li>` elements.

### Making our list

To make our list we loop through the array of features in the GeoJSON FeatureCollection (`nationalParks.features`). In the loop, we will be creating a `<li>` element with park-specific data to place in the left panel. Then we'll attach event listeners.

```javascript
// Again - still in the async function! This is because we need to be sure that nationalParks has the fetched data before we loop through it.
        
nationalParks.features.forEach(function (nationalPark, i) {
    // First we will create the <li> element that will represent the park. This will go inside the <ul class="layers"> element defined in index.html
    let element = `<li class="layer" data-np-id="${nationalPark.properties.id}">
        <div class="layer-element icon" data-type="list-item" data-id="${nationalPark.properties.id}">
        <div class="label">
        <img class='np-arrow-green' src='./assets/img/np-arrow-green.png' />
        <span class='np-name'>${ nationalPark.properties.name }</span>
        <a href="${ nationalPark.properties.url }" target="_blank">
        <i class="material-icons" onClick="this.href='${ nationalPark.properties.url }'" aria-label="">launch</i>
        </a>
        </div>
        </div>
    </li>`
    
    element = $.parseHTML(element);

    // Then, attach event handlers to the element
    $(element).find('span').on('click', function (e) {

        e.preventDefault();
        flyToBoundsOffset(nationalPark.properties.id, '.osel-sliding-side-panel')

    });

    $(element).on('mouseenter', function () {
        highlightGeojson(nationalPark.properties.id)
        highlightListElement(nationalPark.properties.id)
    });
    
    $(element).on('mouseleave', function () {
        unhighlightGeojson(nationalPark.properties.id)
        unhighlightListElement(nationalPark.properties.id)
    });

    // And finally append it to the <li class="layers"> element
    $('.layers').append(element);
}); // <- close the forEach loop
})() // <- and close the function expression - then invoke it!
```

And that's it! Our app fetches the national parks geometries, loads them on the map, adds them to a list on the left panel, and attaches event handlers to highlight and fly to the appropriate park on click. We included an external link icon so users could visit the national park's official website. The perfect launchpad for exploring Great Britain.

Feel free to adapt this code to suit your needs. If you have any questions or make anything cool with OS data - let us know! [@OrdnanceSurvey](https://twitter.com/ordnancesurvey) or [#OSDeveloper](https://twitter.com/hashtag/OSDeveloper)